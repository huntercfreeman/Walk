@using System.Text
@using Walk.TextEditor.RazorLib.TextEditors.Models.Internals
@using Walk.Extensions.CompilerServices.Syntax
@using Walk.Extensions.CompilerServices.Syntax.Nodes
@using Walk.Extensions.CompilerServices.Syntax.Nodes.Enums

@*
    I'm making changes to the C# Compiler Service storage.
    I encountered an infinite loop in the UI when I hovered a certain generic variable.
    The TypeSyntaxDisplay was rendering GenericSyntaxDisplay which then rendered TypeSyntaxDisplay, repeat...
    This spiked my memory, I was able to stop the app with Task Manager, but I want to avoid this happening again at all costs until I am 100% certain
    the new storage won't have an infinite loop in the UI.
*@
@if (SyntaxViewModel.Depth < 6)
{
	var syntaxViewModelLocal = SyntaxViewModel;
	
	string? prefixText;
	string? prefixTextCssClass;
	string? text;
	string? syntaxHighlightingClassCssString;
	bool hasGenericParameterListing;
	bool? hasQuestionMark;
	int arrayRank;
	TypeKind typeKind = TypeKind.ArrayJagged;
	
	if (syntaxViewModelLocal.DefinitionNode.IsDefault() && syntaxViewModelLocal.TargetNode.IsDefault() && syntaxViewModelLocal.TargetSymbol.IsDefault() && TypeReference.IsDefault())
	{
		prefixText = "(null)";
		prefixTextCssClass = null;
		text = null;
		syntaxHighlightingClassCssString = null;
		hasGenericParameterListing = false;
		hasQuestionMark = null;
		arrayRank = 0;
	}
	else if (!syntaxViewModelLocal.DefinitionNode.IsDefault() && syntaxViewModelLocal.DefinitionNode.SyntaxKind == SyntaxKind.TypeDefinitionNode)
	{
		var typeDefinitionNode = (TypeDefinitionNode)syntaxViewModelLocal.DefinitionNode;
	
		var prefixBuilder = new StringBuilder();
		prefixBuilder.Append(typeDefinitionNode.AccessModifierKind.ToString().ToLower());
		prefixBuilder.Append(' ');
		prefixBuilder.Append(typeDefinitionNode.StorageModifierKind.ToString().ToLower());
		
		prefixText = prefixBuilder.ToString();
		prefixTextCssClass = "di_keyword";
		text = syntaxViewModelLocal.GetIdentifierText(typeDefinitionNode);
		syntaxHighlightingClassCssString = "di_type";
		hasGenericParameterListing = typeDefinitionNode.OpenAngleBracketToken.ConstructorWasInvoked;
		hasQuestionMark = null;
		arrayRank = 0;
	}
	else if (!syntaxViewModelLocal.TargetNode.IsDefault() && syntaxViewModelLocal.TargetNode.SyntaxKind == SyntaxKind.TypeClauseNode)
	{
		var typeClauseNode = (TypeClauseNode)syntaxViewModelLocal.TargetNode;
	
		prefixText = "(reference)";
		prefixTextCssClass = null;
		text = syntaxViewModelLocal.GetIdentifierText(typeClauseNode);
		
		if (typeClauseNode.IsKeywordType)
			syntaxHighlightingClassCssString = "di_keyword";
		else
			syntaxHighlightingClassCssString = "di_type";
		
		hasGenericParameterListing = typeClauseNode.OpenAngleBracketToken.ConstructorWasInvoked;
		hasQuestionMark = typeClauseNode.HasQuestionMark;
		arrayRank = typeClauseNode.ArrayRank;
		typeKind = typeClauseNode.TypeKind;
	}
	else if (!syntaxViewModelLocal.TargetSymbol.IsDefault() && syntaxViewModelLocal.TargetSymbol.Value.SyntaxKind == SyntaxKind.TypeSymbol)
	{
		prefixText = "(symbol)";
		prefixTextCssClass = null;
		text = syntaxViewModelLocal.GetTextFromTextSpan(syntaxViewModelLocal.TargetSymbol.Value.TextSpan);
		syntaxHighlightingClassCssString = "di_type";
		hasGenericParameterListing = false;
		hasQuestionMark = null;
		arrayRank = 0;
	}
	else if (!TypeReference.IsDefault())
	{
		prefixText = "(reference)";
		prefixTextCssClass = null;
		
		if (TypeReference.IsImplicit && TypeReference.ExplicitDefinitionResourceUri.Value is not null ||
		    TypeReference.ExplicitDefinitionResourceUri.Value is not null && TypeReference.ExplicitDefinitionTextSpan != default)
    	{
    	    syntaxViewModelLocal.ResourceUri = TypeReference.ExplicitDefinitionResourceUri;
    	    text = syntaxViewModelLocal.GetTextFromTextSpan(TypeReference.ExplicitDefinitionTextSpan);
    	}
    	else
    	{
    	    text = syntaxViewModelLocal.GetTextFromTextSpan(TypeReference.TypeIdentifierToken.TextSpan);
    	}
		
		if (TypeReference.IsKeywordType)
			syntaxHighlightingClassCssString = "di_keyword";
		else
			syntaxHighlightingClassCssString = "di_type";
		
		hasGenericParameterListing = TypeReference.OpenAngleBracketToken.ConstructorWasInvoked;
		hasQuestionMark = TypeReference.HasQuestionMark;
		arrayRank = TypeReference.ArrayRank;
		typeKind = TypeReference.TypeKind;
	}
	else
	{
		prefixText = "(unrecognizable-state)";
		prefixTextCssClass = null;
		text = null;
		syntaxHighlightingClassCssString = null;
		hasGenericParameterListing = false;
		hasQuestionMark = null;
		arrayRank = 0;
	}
    
    <span style="display: inline-flex;">
    	
    	@if (syntaxViewModelLocal.Depth == 0 && !string.IsNullOrWhiteSpace(prefixText))
    	{
    		<span class="@prefixTextCssClass">
    			@prefixText&nbsp;
    		</span>
    	}
    	
    	@if (!string.IsNullOrWhiteSpace(text))
    	{
    		var classCssString = syntaxViewModelLocal.DefinitionNode is null
    			? string.Empty
    			: "di_te_syntax-onclick";
    	
    		<span class="@classCssString @syntaxHighlightingClassCssString"
    			  @onclick="() => syntaxViewModelLocal.HandleOnClick(TextEditorService, SyntaxKind.TypeDefinitionNode)">
    			@text
    		</span>
    	}
    	
    	@if (hasGenericParameterListing)
    	{
			if (!TypeReference.IsDefault())
    		{
    			var syntaxViewModel = new SyntaxViewModel(
        		    SyntaxViewModel.ExtendedCompilerService,
    			    SyntaxViewModel.TextEditorService,
    			    SyntaxViewModel.ResourceUri,
    				targetSymbol: default,
    				targetNode: default,
    				definitionNode: default,
    				depth: syntaxViewModelLocal.Depth + 1);
    			<GenericSyntaxDisplay SyntaxViewModel="syntaxViewModel" TypeReference="TypeReference" />
    		}
    		else
    		{
    			var syntaxViewModel = new SyntaxViewModel(
        		    SyntaxViewModel.ExtendedCompilerService,
    			    SyntaxViewModel.TextEditorService,
    			    SyntaxViewModel.ResourceUri,
    				targetSymbol: default,
    				targetNode: syntaxViewModelLocal.TargetNode,
    				definitionNode: syntaxViewModelLocal.DefinitionNode,
    				depth: syntaxViewModelLocal.Depth + 1);
    			<GenericSyntaxDisplay SyntaxViewModel="syntaxViewModel" />
    		}
    	}
    	
    	@if (hasQuestionMark is not null && hasQuestionMark.Value)
    	{
    		<text>?</text>
    	}
    	
    	@if (arrayRank > 0)
    	{
    	    if (typeKind == TypeKind.ArrayMultiDimensional)
    	    {
    	        <text>[</text>
    	        for (int badIndex = 0; badIndex < arrayRank - 1; badIndex++)
        		{
        			<text>,</text>
        		}
        		<text>]</text>
    	    }
    	    else
    	    {
        		for (int badIndex = 0; badIndex < arrayRank; badIndex++)
        		{
        			<text>[]</text>
        		}
    		}
    	}
    </span>
}
